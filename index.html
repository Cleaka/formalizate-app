<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Osinergmin - Asistente de Formalizaci√≥n (GLP)</title>
    <style>
        :root {
            --primary: #005A9C;
            --secondary: #00A9E0;
            --success: #27ae60;
            --warning: #f39c12;
            --danger: #e74c3c;
            --light: #ecf0f1;
            --dark: #34495e;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: var(--font-family);
        }
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
        }
        header {
            background: var(--primary);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        .logo {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .subtitle {
            font-size: 18px;
            opacity: 0.9;
        }
        .card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 25px;
            margin-bottom: 20px;
        }
        .step { display: none; }
        .step.active { display: block; }
        h2 {
            color: var(--primary);
            margin-bottom: 15px;
            border-bottom: 2px solid var(--light);
            padding-bottom: 10px;
            text-align: center;
        }
        .option-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .option-card {
            border: 2px solid var(--light);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fff;
        }
        .option-card:hover {
            border-color: var(--secondary);
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }
        .option-card.selected {
            border-color: var(--secondary);
            background-color: rgba(0, 169, 224, 0.1);
        }
        .option-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }
        .option-card h3 {
            color: var(--dark);
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        .option-card p {
            font-size: 0.9em;
            color: #777;
            font-weight: bold;
        }
        #question-display {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .question-text {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 20px;
            text-align: center;
        }
        .help-text {
            font-size: 1.0em;
            color: var(--primary);
            background-color: rgba(0, 169, 224, 0.05);
            border: 1px dashed var(--secondary);
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        .answer-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .btn-option {
            display: block;
            width: 100%;
            background-color: #fff;
            color: var(--dark);
            padding: 20px;
            border: 2px solid var(--light);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            text-align: center;
            transition: all 0.2s ease;
        }
        .btn-option:hover {
            border-color: var(--secondary);
            background-color: rgba(0, 169, 224, 0.05);
        }
        .btn-option.selected {
            border-color: var(--secondary);
            background-color: rgba(0, 169, 224, 0.1);
            color: var(--primary);
        }
        .answer-options.binary {
             grid-template-columns: 1fr 1fr;
        }
        .dimensions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            align-items: center;
        }
        .dimensions-grid label {
            font-weight: bold;
            text-align: right;
            font-size: 1.2em;
        }
        input[type="number"] {
            font-size: 1.2em;
            text-align: center;
            font-weight: bold;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        .btn {
            display: inline-block;
            background-color: var(--secondary);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        .btn:hover { background-color: #007bbd; }
        .btn:disabled { background-color: #cccccc; cursor: not-allowed; }
        .btn-prev { background-color: var(--dark); }
        .btn-prev:hover { background-color: #4a637c; }
        .btn-eval { background-color: var(--success); }
        .btn-eval:hover { background-color: #219653; }
        .result {
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
        }
        .result h3 { font-size: 1.8em; margin-bottom: 10px; }
        .result-icon { font-size: 4em; margin-bottom: 15px; }
        .success {
            background-color: rgba(39, 174, 96, 0.1);
            border: 2px solid var(--success);
            color: #219653;
        }
        .danger {
            background-color: rgba(231, 76, 60, 0.1);
            border: 2px solid var(--danger);
            color: #c0392b;
        }
        .capacity-box {
            background-color: #fff;
            border: 2px solid var(--success);
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: left;
        }
        .capacity-box p {
            font-size: 1.1em;
            margin-bottom: 10px;
        }
        .capacity-box ul {
            text-align: left;
            margin-left: 20px;
            margin-bottom: 10px;
            list-style-type: '‚û°Ô∏è ';
            padding-left: 10px;
        }
        .capacity-box li {
            padding-left: 5px;
            margin-bottom: 5px;
        }
        .capacity-box .final-capacity {
            font-size: 1.6em;
            font-weight: bold;
            color: var(--primary);
            text-align: center;
        }
        .failures-list {
            margin-top: 20px;
            text-align: left;
        }
        .failure-item {
            padding: 15px;
            margin-bottom: 10px;
            border-left: 5px solid var(--danger);
            background-color: rgba(231, 76, 60, 0.05);
            color: #c0392b;
            font-weight: bold;
        }
        .recommendation-item {
             padding: 15px;
            margin-top: 20px;
            border-left: 5px solid var(--warning);
            background-color: rgba(243, 156, 18, 0.1);
            color: #d35400;
            font-weight: 500;
            text-align: left;
        }
        .progress-bar {
            height: 10px;
            background-color: var(--light);
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background-color: var(--secondary);
            width: 0%;
            transition: width 0.5s ease;
        }
        .dni-section {
            background-color: rgba(0, 169, 224, 0.05);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .hidden { display: none; }
        .declaration {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        .form-group input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .reference-image {
            max-width: 100%;
            border-radius: 8px;
            margin: 15px auto;
            display: block;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border: 1px solid #ddd;
        }
        .image-caption {
            text-align: center;
            font-style: italic;
            color: #666;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">üõ°Ô∏è Osinergmin</div>
            <div class="subtitle">Asistente de Pre-evaluaci√≥n para Venta de GLP</div>
        </header>

        <div class="dni-section card">
            <h2>¬°Bienvenido! üëã</h2>
            <p style="text-align: center; margin-bottom: 20px;">Te ayudaremos a revisar si tu local cumple los requisitos de seguridad. Para guardar tu avance y usarlo en la oficina, ingresa tu DNI.</p>
            <div class="form-group">
                <label for="dni">Ingresa tu DNI (8 d√≠gitos):</label>
                <input type="tel" id="dni" placeholder="Ej: 12345678" maxlength="8" pattern="[0-9]{8}">
            </div>
            <button class="btn" id="saveDni">Guardar DNI y Empezar</button>
            <div id="dniMessage" style="margin-top: 15px; text-align: center; font-weight: bold;"></div>
        </div>

        <div class="card" id="wizard-container" style="display: none;">
            <div class="progress-bar">
                <div class="progress" id="progress"></div>
            </div>

            <div class="step active" id="step1">
                <h2>1. ¬øC√≥mo almacenar√°s el gas?</h2>
                <div class="option-grid">
                    <div class="option-card" data-option="1">
                        <div class="option-icon">üóÑÔ∏è</div>
                        <h3>En Rack / Jaula</h3>
                        <p>Hasta 120 kg</p>
                    </div>
                    <div class="option-card" data-option="2">
                        <div class="option-icon">üè†</div>
                        <h3>Local con Techo</h3>
                        <p>Hasta 5,000 kg</p>
                    </div>
                    <div class="option-card" data-option="3">
                        <div class="option-icon">‚òÄÔ∏è</div>
                        <h3>Local sin Techo</h3>
                        <p>Hasta 50,000 kg</p>
                    </div>
                </div>
            </div>

            <div class="step" id="step2">
                <h2 id="question-title">2. Revisi√≥n de Seguridad</h2>
                <div id="question-display"></div>
                <div class="navigation-buttons">
                    <button class="btn btn-prev" id="prevQuestion">‚¨ÖÔ∏è Anterior</button>
                    <button class="btn" id="nextQuestion">Siguiente ‚û°Ô∏è</button>
                </div>
            </div>

            <div class="step" id="step3">
                <h2>Resultado de la Pre-evaluaci√≥n</h2>
                <div id="result-container"></div>
                <button class="btn" id="restart">Revisar de Nuevo</button>
            </div>
        </div>

        <div class="declaration hidden" id="declaration">
            <h2>Declaraci√≥n Jurada</h2>
            <p><strong>DNI:</strong> <span id="decl-dni"></span></p>
            <p>Con esta fecha, declaro que las respuestas marcadas son verdaderas y reflejan la realidad de mi local.</p>
            <div id="declaration-content"></div>
            <button class="btn" id="printDeclaration">Imprimir DJ</button>
        </div>
    </div>

    <script>
        // --- CONSTANTES ---
        const TRANSFORMERMINDISTANCE = 7.6;
        const VENTILATIONMINAREA = 6;
        const PISOS_SUPERIORES_LIMIT = 300;
        const BALON_DIAMETER = 0.310; // 31cm
        const MIN_DIMENSION_TOTAL = 2; // 1m de despeje * 2
        
        // --- NUEVA CONSTANTE (GRUPOS Y PASILLOS) ---
        const AISLE_WIDTH = 2; // 2 metros de pasillo
        const GROUP_MAX_KG = 2000; // 2000 kg por grupo

        // --- RESTRICCIONES (REEMPLAZAN 4.6m) ---
        const wallClearanceTiers = [
            { minKg: 0, maxKg: 500, clearance: 1 },
            { minKg: 501, maxKg: 1000, clearance: 2 },
            { minKg: 1001, maxKg: 3000, clearance: 3 },
            { minKg: 3001, maxKg: 4500, clearance: 4 },
            { minKg: 4501, maxKg: 6000, clearance: 5 },
            { minKg: 6001, maxKg: 10000, clearance: 6 },
            { minKg: 10001, maxKg: 20000, clearance: 8 },
            { minKg: 20001, maxKg: 50000, clearance: 10 }
        ];

        // --- RESTRICCI√ìN (AFLUENCIA P√öBLICO) ---
        const publicClearanceTiers = [
            { maxKg: 500, distance: 3 },
            { maxKg: 1000, distance: 4 },
            { maxKg: 3000, distance: 6 },
            { maxKg: 4500, distance: 8 },
            { maxKg: 6000, distance: 8 }, 
            { maxKg: 10000, distance: 12 },
            { maxKg: 20000, distance: 16 },
            { maxKg: 50000, distance: 20 }
        ];

        // --- PREGUNTAS ---

        const newPublicQuestions = [
            {
                id: 'public_nearby',
                text: '¬øExisten lugares de afluencia de p√∫blico cercanos? (Ej: hospitales, cl√≠nicas, colegios, mercados, iglesias, cines, cuarteles, comisar√≠as, penales, etc.)',
                type: 'binary',
                options: ['S√≠, hay uno cerca', 'No hay ninguno'],
                critical: false 
            },
            {
                id: 'public_distance',
                text: '¬øA cu√°ntos metros est√° el lugar de afluencia de p√∫blico m√°s cercano?',
                type: 'number',
                helpText: 'Mida la distancia en l√≠nea recta desde el borde de su almac√©n hasta el borde del otro local. Esta distancia restringir√° su capacidad m√°xima.',
                critical: false, 
                dependsOn: { id: 'public_nearby', value: 'S√≠, hay uno cerca' }, 
                condition: (answer) => true, 
                failureMessage: ''
            }
        ];

        const questionSets = {
            1: [ // RACK
                {
                    id: 'has_retiro',
                    text: '¬øTu casa tiene un "retiro"? (Un espacio o jard√≠n entre tu puerta y la vereda)',
                    type: 'binary',
                    options: ['S√≠, tengo retiro', 'No, mi casa da a la vereda'],
                    critical: true,
                    condition: (answer) => answer === 'S√≠, tengo retiro',
                    failureMessage: 'Para usar un Rack (jaula), es obligatorio tener un espacio de retiro. No puede estar en la vereda.',
                    referenceImage: {
                        src: 'https://images.unsplash.com/photo-1568605114967-8130f3a36994?ixlib=rb-4.0.3&auto=format&fit=crop&w=600&q=80',
                        caption: 'Ejemplo de casa con retiro (espacio entre la puerta y la vereda)'
                    }
                },
                {
                    id: 'businesses',
                    text: '‚ö†Ô∏è ¬°Atenci√≥n! ¬øAlguno de tus vecinos (costados, atr√°s, frente) tiene un taller de soldadura, mec√°nica, carpinter√≠a o un negocio que bote chispas?',
                    type: 'binary',
                    options: ['S√≠, hay un taller cerca', 'No, son casas o bodegas'],
                    critical: true,
                    condition: (answer) => answer === 'No, son casas o bodegas',
                    failureMessage: 'No puedes almacenar gas cerca de negocios que generen chispas (talleres, soldadura) por alto riesgo de explosi√≥n.'
                },
                {
                    id: 'transformer_nearby',
                    text: '¬øHay alg√∫n transformador el√©ctrico (ese gris en el poste) cerca?',
                    type: 'binary',
                    options: ['S√≠, hay uno cerca', 'No hay ninguno cerca'],
                    critical: false,
                    referenceImage: {
                        src: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiIq6ggfAnfQ1-1Tyi0iP7WXsALeSaeSZAy3PQ1wqRJW6Z9L9yEOglNGF1z8i-Z_vKUkkx7RDy3U2sfcDdq2pZSxdQCU77b_OanU8xvO-s2Bgu3VjSK-isQ1Cjn1Byyl26KNa_-IBAN6JM/s1600/subeaerea.jpg',
                        caption: 'Transformador el√©ctrico t√≠pico (gris) en poste'
                    }
                },
                {
                    id: 'transformer_distance',
                    text: '¬øA cu√°ntos metros est√° el transformador de tu RACK?',
                    type: 'number',
                    helpText: `Mide en l√≠nea recta desde donde ir√° el rack hasta el transformador. La distancia m√≠nima es ${TRANSFORMERMINDISTANCE} metros.`,
                    critical: true,
                    dependsOn: { id: 'transformer_nearby', value: 'S√≠, hay uno cerca' }, 
                    condition: (answer) => parseFloat(answer) >= TRANSFORMERMINDISTANCE,
                    failureMessage: `La distancia m√≠nima al transformador debe ser ${TRANSFORMERMINDISTANCE} metros. El riesgo el√©ctrico es muy alto.`
                }
            ],
            2: [ // CON TECHO
                {
                    id: 'ventilation_type',
                    text: '¬øLa ventilaci√≥n de tu almac√©n es PERMANENTE? (Ej: rejas, calados, un hueco que no se puede cerrar)',
                    type: 'binary',
                    options: ['S√≠, es permanente (rejas)', 'No, tiene ventanas o se cierra'],
                    critical: true,
                    condition: (answer) => answer === 'S√≠, es permanente (rejas)',
                    failureMessage: 'La ventilaci√≥n debe ser permanente (con rejas). Las ventanas que se cierran no cuentan.'
                },
                {
                    id: 'ventilation_size',
                    text: '¬øQu√© tama√±o tiene esa ventilaci√≥n (en metros cuadrados)?',
                    type: 'number',
                    helpText: `Mide el ANCHO y el ALTO de tu reja. El m√≠nimo es ${VENTILATIONMINAREA} m¬≤. ¬°Importante! El tama√±o de tu ventilaci√≥n afectar√° tu capacidad m√°xima de almac√©n.`,
                    critical: true,
                    condition: (answer) => parseFloat(answer) >= VENTILATIONMINAREA,
                    failureMessage: `La ventilaci√≥n debe ser de al menos ${VENTILATIONMINAREA} metros cuadrados para asegurar que el gas escape si hay una fuga.`
                },
                {
                    id: 'businesses',
                    text: '‚ö†Ô∏è ¬°Atenci√≥n! ¬øAlguno de tus vecinos (costados, atr√°s, frente) tiene un taller de soldadura, mec√°nica, carpinter√≠a o un negocio que bote chispas?',
                    type: 'binary',
                    options: ['S√≠, hay un taller cerca', 'No, son casas o bodegas'],
                    critical: true,
                    condition: (answer) => answer === 'No, son casas o bodegas',
                    failureMessage: 'No puedes almacenar gas cerca de negocios que generen chispas (talleres, soldadura) por alto riesgo de explosi√≥n.'
                },
                {
                    id: 'transformer_nearby',
                    text: '¬øHay alg√∫n transformador el√©ctrico (ese gris en el poste) cerca?',
                    type: 'binary',
                    options: ['S√≠, hay uno cerca', 'No hay ninguno cerca'],
                    critical: false,
                    referenceImage: {
                        src: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiIq6ggfAnfQ1-1Tyi0iP7WXsALeSaeSZAy3PQ1wqRJW6Z9L9yEOglNGF1z8i-Z_vKUkkx7RDy3U2sfcDdq2pZSxdQCU77b_OanU8xvO-s2Bgu3VjSK-isQ1Cjn1Byyl26KNa_-IBAN6JM/s1600/subeaerea.jpg',
                        caption: 'Transformador el√©ctrico t√≠pico (gris) en poste'
                    }
                },
                {
                    id: 'transformer_distance',
                    text: '¬øA cu√°ntos metros est√° el transformador de tu ALMAC√âN?',
                    type: 'number',
                    helpText: `Mide en l√≠nea recta desde el borde de tu almac√©n hasta el transformador. El m√≠nimo es ${TRANSFORMERMINDISTANCE} metros.`,
                    critical: true,
                    dependsOn: { id: 'transformer_nearby', value: 'S√≠, hay uno cerca' }, 
                    condition: (answer) => parseFloat(answer) >= TRANSFORMERMINDISTANCE,
                    failureMessage: `La distancia m√≠nima al transformador debe ser ${TRANSFORMERMINDISTANCE} metros.`
                },
                // ... (Nuevas preguntas de afluencia se insertar√°n aqu√≠) ...
                {
                    id: 'materials_roof',
                    text: '¬øDe qu√© material es el TECHO de tu almac√©n?',
                    type: 'options',
                    options: ['Ladrillo / Cemento (Noble)', 'Madera / Quincha', 'Estera / Pl√°stico / Calamina'],
                    critical: true,
                    condition: (answer) => answer === 'Ladrillo / Cemento (Noble)',
                    failureMessage: 'El TECHO no puede ser de material inflamable (madera, estera, pl√°stico, calamina sobre madera).'
                },
                {
                    id: 'materials_floor',
                    text: '¬øDe qu√© material es el PISO de tu almac√©n?',
                    type: 'options',
                    options: ['Cemento / Concreto / Loseta', 'Tierra / Afirmado', 'Madera / Pl√°stico / Vin√≠lico'],
                    critical: true,
                    condition: (answer) => answer === 'Cemento / Concreto / Loseta' || answer === 'Tierra / Afirmado',
                    failureMessage: 'El PISO no puede ser de material inflamable (madera, pl√°stico, vin√≠lico).'
                },
                {
                    id: 'materials_walls',
                    text: '¬øDe qu√© material son las PAREDES de tu almac√©n?',
                    type: 'options',
                    options: ['Ladrillo / Cemento (Noble)', 'Madera / Quincha', 'Estera / Pl√°stico / Drywall'],
                    critical: true,
                    condition: (answer) => answer === 'Ladrillo / Cemento (Noble)',
                    failureMessage: 'Las PAREDES no pueden ser de material inflamable (madera, estera, drywall).'
                },
                {
                    id: 'pisos_superiores',
                    text: '¬øHay pisos superiores (otra vivienda, oficinas) ENCIMA de tu almac√©n?',
                    type: 'binary',
                    options: ['S√≠, hay pisos arriba', 'No, es el primer piso / techo libre'],
                    critical: false,
                    helpText: 'Si hay construcci√≥n sobre tu almac√©n, la capacidad m√°xima se restringe por seguridad a 300 kg.'
                },
                {
                    id: 'puerta_adicional',
                    text: 'Adem√°s de la puerta principal, ¬øtu almac√©n tiene OTRA puerta de salida?',
                    type: 'binary',
                    options: ['S√≠, tiene otra puerta', 'No, solo tiene una entrada'],
                    critical: false,
                    condition: (answer) => answer === 'No, solo tiene una entrada',
                    recommendationMessage: 'RECOMENDACI√ìN: Si tienes una puerta adicional, esta debe ser clausurada (sellada) para la supervisi√≥n de Osinergmin.'
                },
                {
                    id: 'haselectricityrecommendation',
                    text: '¬øHay cables el√©ctricos, enchufes o tomacorrientes DENTRO del almac√©n?',
                    type: 'binary',
                    options: ['S√≠, hay cables/enchufes', 'No, no hay nada el√©ctrico'],
                    critical: false,
                    condition: (answer) => answer === 'No, no hay nada el√©ctrico',
                    recommendationMessage: 'RECOMENDACI√ìN: Debes retirar todas las conexiones el√©ctricas (cables, enchufes, focos) del interior del almac√©n.'
                },
                {
                    id: 'storage_dimensions',
                    text: 'Ingresa las medidas TOTALES de tu almac√©n (en metros):',
                    type: 'dimensions',
                    helpText: `¬°Importante! La norma exige un despeje (espacio libre) que depende de la cantidad a almacenar. Adem√°s, si almacenas m√°s de ${GROUP_MAX_KG}kg, se requerir√°n pasillos adicionales de ${AISLE_WIDTH}m entre grupos, lo cual reduce m√°s el espacio √∫til. Tu local debe medir al menos ${MIN_DIMENSION_TOTAL}m x ${MIN_DIMENSION_TOTAL}m.`,
                    critical: true,
                    condition: (answer) => {
                        if (!answer || typeof answer.largo === 'undefined' || typeof answer.ancho === 'undefined') return false; 
                        return parseFloat(answer.largo) >= MIN_DIMENSION_TOTAL && parseFloat(answer.ancho) >= MIN_DIMENSION_TOTAL;
                    },
                    failureMessage: `El espacio es muy peque√±o. Para cumplir la norma de despeje, tu local debe medir al menos ${MIN_DIMENSION_TOTAL} x ${MIN_DIMENSION_TOTAL} metros.`
                }
            ],
            3: [ // SIN TECHO
                {
                    id: 'businesses',
                    text: '‚ö†Ô∏è ¬°Atenci√≥n! ¬øAlguno de tus vecinos (costados, atr√°s, frente) tiene un taller de soldadura, mec√°nica, carpinter√≠a o un negocio que bote chispas?',
                    type: 'binary',
                    options: ['S√≠, hay un taller cerca', 'No, son casas o bodegas'],
                    critical: true,
                    condition: (answer) => answer === 'No, son casas o bodegas',
                    failureMessage: 'No puedes almacenar gas cerca de negocios que generen chispas (talleres, soldadura) por alto riesgo de explosi√≥n.'
                },
                {
                    id: 'transformer_nearby',
                    text: '¬øHay alg√∫n transformador el√©ctrico (ese gris en el poste) cerca?',
                    type: 'binary',
                    options: ['S√≠, hay uno cerca', 'No hay ninguno cerca'],
                    critical: false,
                    referenceImage: {
                        src: 'https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiIq6ggfAnfQ1-1Tyi0iP7WXsALeSaeSZAy3PQ1wqRJW6Z9L9yEOglNGF1z8i-Z_vKUkkx7RDy3U2sfcDdq2pZSxdQCU77b_OanU8xvO-s2Bgu3VjSK-isQ1Cjn1Byyl26KNa_-IBAN6JM/s1600/subeaerea.jpg',
                        caption: 'Transformador el√©ctrico t√≠pico (gris) en poste'
                    }
                },
                {
                    id: 'transformer_distance',
                    text: '¬øA cu√°ntos metros est√° el transformador de tu √ÅREA de almac√©n?',
                    type: 'number',
                    helpText: `Mide en l√≠nea recta desde el borde de tu almac√©n hasta el transformador. El m√≠nimo es ${TRANSFORMERMINDISTANCE} metros.`,
                    critical: true,
                    dependsOn: { id: 'transformer_nearby', value: 'S√≠, hay uno cerca' }, 
                    condition: (answer) => parseFloat(answer) >= TRANSFORMERMINDISTANCE,
                    failureMessage: `La distancia m√≠nima al transformador debe ser ${TRANSFORMERMINDISTANCE} metros.`
                },
                 // ... (Nuevas preguntas de afluencia se insertar√°n aqu√≠) ...
                {
                    id: 'materials_roof',
                    text: '¬øUsar√°s alg√∫n toldo o techo temporal sobre el √°rea?',
                    type: 'binary',
                    options: ['S√≠, pondr√© un toldo/techo', 'No, estar√° a cielo abierto'],
                    critical: true,
                    condition: (answer) => answer === 'No, estar√° a cielo abierto',
                    failureMessage: 'En un local "Sin Techo", el √°rea de balones debe estar a cielo abierto, sin toldos o coberturas inflamables.'
                },
                 {
                    id: 'materials_floor',
                    text: '¬øDe qu√© material es el PISO de tu almac√©n?',
                    type: 'options',
                    options: ['Cemento / Concreto / Loseta', 'Tierra / Afirmado', 'Madera / Pl√°stico / Grass'],
                    critical: true,
                    condition: (answer) => answer === 'Cemento / Concreto / Loseta' || answer === 'Tierra / Afirmado',
                    failureMessage: 'El PISO no puede ser de material inflamable (madera, pl√°stico, grass).'
                },
                {
                    id: 'materials_walls',
                    text: '¬øDe qu√© material son las PAREDES que rodean el almac√©n?',
                    type: 'options',
                    options: ['Ladrillo / Cemento (Noble)', 'Madera / Quincha', 'Estera / Pl√°stico / Drywall'],
                    critical: true,
                    condition: (answer) => answer === 'Ladrillo / Cemento (Noble)',
                    failureMessage: 'Las PAREDES que rodean el local no pueden ser de material inflamable (madera, estera, drywall).'
                },
                {
                    id: 'haselectricityrecommendation',
                    text: '¬øPasan cables el√©ctricos o hay enchufes en esa √°rea?',
                    type: 'binary',
                    options: ['S√≠, hay cables/enchufes', 'No, no hay nada el√©ctrico'],
                    critical: false,
                    condition: (answer) => answer === 'No, no hay nada el√©ctrico', 
                    recommendationMessage: 'RECOMENDACI√ìN: Debes retirar todas las conexiones el√©ctricas (cables, enchufes) del √°rea de almacenamiento.'
                },
                {
                    id: 'storage_dimensions',
                    text: 'Ingresa las medidas TOTALES de tu √°rea de almac√©n (en metros):',
                    type: 'dimensions',
                    helpText: `¬°Importante! La norma exige un despeje (espacio libre) que depende de la cantidad a almacenar. Adem√°s, si almacenas m√°s de ${GROUP_MAX_KG}kg, se requerir√°n pasillos adicionales de ${AISLE_WIDTH}m entre grupos, lo cual reduce m√°s el espacio √∫til. Tu √°rea debe medir al menos ${MIN_DIMENSION_TOTAL}m x ${MIN_DIMENSION_TOTAL}m.`,
                    critical: true,
                    condition: (answer) => {
                        if (!answer || typeof answer.largo === 'undefined' || typeof answer.ancho === 'undefined') return false; 
                        return parseFloat(answer.largo) >= MIN_DIMENSION_TOTAL && parseFloat(answer.ancho) >= MIN_DIMENSION_TOTAL;
                    },
                    failureMessage: `El espacio es muy peque√±o. Para cumplir la norma de despeje, tu √°rea debe medir al menos ${MIN_DIMENSION_TOTAL} x ${MIN_DIMENSION_TOTAL} metros.`
                }
            ]
        };

        // --- Insertar las nuevas preguntas en los sets 2 y 3 ---
        questionSets[2].splice(5, 0, ...newPublicQuestions); // Inserta despu√©s de transformer_distance (√≠ndice 4)
        questionSets[3].splice(3, 0, ...newPublicQuestions); // Inserta despu√©s de transformer_distance (√≠ndice 2)


        // --- FUNCIONES HELPER DE C√ÅLCULO ---

        /**
         * Calcula la capacidad en KG basada en el espacio √∫til (ya descontado el despeje).
         */
        function calculateCapacityFromUsableSpace(usableLargo, usableAncho) {
            if (usableLargo <= 0 || usableAncho <= 0) return 0;
            
            const balonesPorFilaLargo = Math.floor(usableLargo / BALON_DIAMETER);
            const balonesPorFilaAncho = Math.floor(usableAncho / BALON_DIAMETER);
            const balonesPorNivel = balonesPorFilaLargo * balonesPorFilaAncho;
            const balonesCount = balonesPorNivel * 2; // 2 niveles de apilamiento
            return balonesCount * 10; // 10kg por bal√≥n
        }

        /**
         * Itera por todos los niveles de despeje para encontrar la capacidad m√°xima "ganadora".
         * APLICA LA L√ìGICA DE PASILLOS SI SE SUPERA GROUP_MAX_KG.
         */
        function calculateMaxCapacity(totalLargo, totalAncho) {
            let maxAchievableCapacity = 0;
            let bestClearance = 0;
            
            const k = (2 * 10) / (BALON_DIAMETER * BALON_DIAMETER); // Constante de capacidad por m¬≤
            const Wp = AISLE_WIDTH;
            const Gmax = GROUP_MAX_KG;

            for (const tier of wallClearanceTiers) {
                const clearance = tier.clearance;
                const usableLargo = totalLargo - (clearance * 2);
                const usableAncho = totalAncho - (clearance * 2);

                if (usableLargo <= 0 || usableAncho <= 0) continue;

                let potential_capacity = 0;
                
                // 1. Calcular capacidad sin pasillos
                const capacity_no_aisles = calculateCapacityFromUsableSpace(usableLargo, usableAncho);

                // 2. Comprobar si se necesita la l√≥gica de pasillos
                if (capacity_no_aisles <= Gmax) {
                    // No se necesitan pasillos, la capacidad es la calculada
                    potential_capacity = capacity_no_aisles;
                } else {
                    // S√≠ se necesitan pasillos. Usar la f√≥rmula algebraica para encontrar la capacidad estable.
                    
                    // Caso 1: Pasillos se restan del Largo (se apila a lo ancho)
                    const k_Au_Wp_Gmax = (k * usableAncho * Wp) / Gmax;
                    const k_Au_Lu_Wp = k * usableAncho * (usableLargo + Wp);
                    // El + Wp es para corregir el N-1 (grupos - 1 pasillos)
                    const capacity_largo = k_Au_Lu_Wp / (1 + k_Au_Wp_Gmax);

                    // Caso 2: Pasillos se restan del Ancho (se apila a lo largo)
                    const k_Lu_Wp_Gmax = (k * usableLargo * Wp) / Gmax;
                    const k_Lu_Au_Wp = k * usableLargo * (usableAncho + Wp);
                    const capacity_ancho = k_Lu_Au_Wp / (1 + k_Lu_Wp_Gmax);

                    // La capacidad potencial es la mejor de las dos orientaciones
                    potential_capacity = Math.max(capacity_largo, capacity_ancho);
                }
                
                // 3. Limitar por el m√°ximo del "tier" de despeje
                const tier_limited_capacity = Math.min(potential_capacity, tier.maxKg);

                // 4. "El ganador": Buscamos la mayor capacidad lograda en todas las pruebas
                if (tier_limited_capacity > maxAchievableCapacity) {
                    maxAchievableCapacity = tier_limited_capacity;
                    bestClearance = clearance;
                }
            }
            
            // Retorna la capacidad ganadora y el despeje que la logr√≥
            return { capacity: maxAchievableCapacity, clearance: bestClearance };
        }

        /**
         * Obtiene el l√≠mite de KG permitido seg√∫n la distancia a un lugar p√∫blico.
         */
        function getLimitFromDistance(distance, tiers) {
            let allowedKg = 0; // Si no cumple ni el m√≠nimo, es 0
            for (const tier of tiers) {
                if (distance >= tier.distance) {
                    allowedKg = tier.maxKg; // Sigue actualizando al m√°ximo permitido
                } else {
                    break; // Se detiene en cuanto no cumple una distancia
                }
            }
            return allowedKg;
        }


        // --- VARIABLES GLOBALES ---
        let currentStep = 1;
        let currentQuestionIndex = 0;
        let selectedOption = null;
        let currentQuestionSet = [];
        let userData = {
            dni: '',
            option: '',
            optionText: '',
            answers: {},
            result: '',
            failures: [],
            recommendations: []
        };
        let totalQuestions = 0;

        // --- ELEMENTOS DOM ---
        let steps, progressBar, dniInput, saveDniBtn, dniMessage, wizardContainer;
        let optionCards, questionDisplay, nextQuestionBtn, prevQuestionBtn;
        let resultContainer, restartBtn, declaration, declDni, declarationContent, printDeclarationBtn;

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', function () {
            
            // Asignamos las variables DESPU√âS de que el DOM est√© listo
            steps = document.querySelectorAll('.step');
            progressBar = document.getElementById('progress');
            dniInput = document.getElementById('dni');
            saveDniBtn = document.getElementById('saveDni');
            dniMessage = document.getElementById('dniMessage');
            wizardContainer = document.getElementById('wizard-container');
            optionCards = document.querySelectorAll('.option-card');
            questionDisplay = document.getElementById('question-display');
            nextQuestionBtn = document.getElementById('nextQuestion');
            prevQuestionBtn = document.getElementById('prevQuestion');
            resultContainer = document.getElementById('result-container');
            restartBtn = document.getElementById('restart');
            declaration = document.getElementById('declaration');
            declDni = document.getElementById('decl-dni');
            declarationContent = document.getElementById('declaration-content');
            printDeclarationBtn = document.getElementById('printDeclaration');

            // Verificar que los elementos existen antes de agregar event listeners
            if (saveDniBtn) {
                saveDniBtn.addEventListener('click', saveDni);
            }
            
            if (dniInput) {
                dniInput.addEventListener('keyup', (e) => { 
                    if(e.key === 'Enter') saveDni(); 
                });
            }

            optionCards.forEach(card => {
                card.addEventListener('click', function () {
                    selectOption(this);
                    setTimeout(goToStep2, 300); 
                });
            });

            if (nextQuestionBtn) {
                nextQuestionBtn.addEventListener('click', nextQuestion);
            }
            
            if (prevQuestionBtn) {
                prevQuestionBtn.addEventListener('click', prevQuestion);
            }
            
            if (restartBtn) {
                restartBtn.addEventListener('click', restartEvaluation);
            }
            
            if (printDeclarationBtn) {
                printDeclarationBtn.addEventListener('click', printDeclaration);
            }
        });


        // --- FUNCIONES PRINCIPALES ---

        function saveDni() {
            const dni = dniInput.value.trim();
            if (dni.length === 8 && /^[0-9]+$/.test(dni)) {
                userData.dni = dni;
                dniMessage.textContent = '‚úì DNI guardado. ¬°Comencemos!';
                dniMessage.style.color = 'green';
                dniInput.disabled = true;
                saveDniBtn.disabled = true;
                wizardContainer.style.display = 'block';
                updateProgress();
            } else {
                dniMessage.textContent = 'Ingresa un DNI v√°lido (8 n√∫meros).';
                dniMessage.style.color = 'red';
            }
        }

        function selectOption(card) {
            optionCards.forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
            selectedOption = card.getAttribute('data-option');
            currentQuestionSet = questionSets[selectedOption];
            totalQuestions = currentQuestionSet.length;
            
            userData.option = selectedOption;
            userData.optionText = card.querySelector('h3').textContent;
        }

        function goToStep(stepNumber) {
            currentStep = stepNumber;
            steps.forEach(step => step.classList.remove('active'));
            document.getElementById(`step${stepNumber}`).classList.add('active');
            updateProgress();
        }

        function goToStep2() {
            if (!selectedOption) return;
            currentQuestionIndex = 0;
            userData.answers = {}; 
            showQuestion(currentQuestionIndex);
            goToStep(2);
        }

        function updateProgress() {
            let progressPercent = 0;
            if (currentStep === 1) {
                progressPercent = 5;
            } else if (currentStep === 2) {
                if (totalQuestions === 0) {
                    progressPercent = 10;
                } else {
                    progressPercent = 10 + (currentQuestionIndex / totalQuestions) * 80;
                }
            } else if (currentStep === 3) {
                progressPercent = 100;
            }
            progressBar.style.width = `${progressPercent}%`;
        }

        // --- L√ìGICA DEL ASISTENTE (PASO 2) ---

        function showQuestion(index) {
            questionDisplay.innerHTML = '';
            
            if (index < 0 || index >= totalQuestions) {
                if (index < 0) {
                    goToStep(1);
                    return;
                } else {
                    evaluateAnswers();
                    return;
                }
            }

            const question = currentQuestionSet[index];
            
            if (question.dependsOn) {
                const dependency = question.dependsOn;
                const dependencyAnswer = userData.answers[dependency.id];
                
                if (dependencyAnswer !== dependency.value) {
                    userData.answers[question.id] = 'N/A (Saltada)';
                    showQuestion(index + 1);
                    return;
                }
            }

            currentQuestionIndex = index;
            
            const qText = document.createElement('div');
            qText.className = 'question-text';
            qText.textContent = question.text;
            questionDisplay.appendChild(qText);
            
            // Agregar imagen referencial si existe
            if (question.referenceImage) {
                const qImage = document.createElement('img');
                qImage.className = 'reference-image';
                qImage.src = question.referenceImage.src;
                qImage.alt = question.referenceImage.caption;
                questionDisplay.appendChild(qImage);
                
                const qImageCaption = document.createElement('div');
                qImageCaption.className = 'image-caption';
                qImageCaption.textContent = question.referenceImage.caption;
                questionDisplay.appendChild(qImageCaption);
            }
            
            if (question.helpText) {
                const qHelp = document.createElement('div');
                qHelp.className = 'help-text';
                qHelp.textContent = `üí° ${question.helpText}`;
                questionDisplay.appendChild(qHelp);
            }

            const qOptions = document.createElement('div');
            const savedAnswer = userData.answers[question.id];

            switch (question.type) {
                case 'binary':
                case 'options':
                    qOptions.className = `answer-options ${question.type === 'binary' ? 'binary' : ''}`;
                    
                    question.options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.className = 'btn-option';
                        btn.textContent = opt;
                        
                        if (savedAnswer === opt) {
                            btn.classList.add('selected');
                        }
                        
                        btn.onclick = () => {
                            qOptions.querySelectorAll('.btn-option').forEach(b => b.classList.remove('selected'));
                            btn.classList.add('selected');
                            userData.answers[question.id] = opt;
                            
                            if (currentQuestionIndex === totalQuestions - 1) {
                                setTimeout(evaluateAnswers, 500);
                            } else {
                                setTimeout(() => showQuestion(currentQuestionIndex + 1), 500);
                            }
                        };
                        qOptions.appendChild(btn);
                    });
                    break;
                    
                case 'number':
                    qOptions.className = 'answer-options';
                    
                    const inputContainer = document.createElement('div');
                    inputContainer.style.textAlign = 'center';
                    inputContainer.style.margin = '20px 0';
                    
                    const inputNum = document.createElement('input');
                    inputNum.type = 'number';
                    inputNum.placeholder = '0.0';
                    inputNum.step = '0.1';
                    inputNum.min = '0';
                    inputNum.style.fontSize = '1.2em';
                    inputNum.style.padding = '12px';
                    inputNum.style.width = '200px';
                    inputNum.style.textAlign = 'center';
                    
                    if (savedAnswer && savedAnswer !== 'N/A (Saltada)') {
                        inputNum.value = savedAnswer;
                    }
                    
                    inputNum.addEventListener('input', function() {
                        userData.answers[question.id] = this.value;
                    });
                    
                    inputContainer.appendChild(inputNum);
                    qOptions.appendChild(inputContainer);
                    break;
                    
                case 'dimensions':
                    qOptions.className = 'dimensions-grid';
                    
                    if (!savedAnswer || typeof savedAnswer !== 'object') {
                        userData.answers[question.id] = { largo: '', ancho: '' };
                    }
                    
                    const labelLargo = document.createElement('label');
                    labelLargo.setAttribute('for', `dim-largo-${question.id}`);
                    labelLargo.textContent = 'Largo (m):';
                    
                    const inputLargo = document.createElement('input');
                    inputLargo.type = 'number';
                    inputLargo.id = `dim-largo-${question.id}`;
                    inputLargo.placeholder = 'Ej: 10.0';
                    inputLargo.step = '0.1';
                    inputLargo.min = '0';
                    inputLargo.value = userData.answers[question.id].largo || '';
                    
                    const labelAncho = document.createElement('label');
                    labelAncho.setAttribute('for', `dim-ancho-${question.id}`);
                    labelAncho.textContent = 'Ancho (m):';
                    
                    const inputAncho = document.createElement('input');
                    inputAncho.type = 'number';
                    inputAncho.id = `dim-ancho-${question.id}`;
                    inputAncho.placeholder = 'Ej: 10.0';
                    inputAncho.step = '0.1';
                    inputAncho.min = '0';
                    inputAncho.value = userData.answers[question.id].ancho || '';
                    
                    inputLargo.addEventListener('input', function() {
                        userData.answers[question.id].largo = this.value;
                    });
                    
                    inputAncho.addEventListener('input', function() {
                        userData.answers[question.id].ancho = this.value;
                    });
                    
                    qOptions.appendChild(labelLargo);
                    qOptions.appendChild(inputLargo);
                    qOptions.appendChild(labelAncho);
                    qOptions.appendChild(inputAncho);
                    break;
            }
            
            questionDisplay.appendChild(qOptions);
            
            prevQuestionBtn.disabled = (index === 0);
            nextQuestionBtn.textContent = (index === totalQuestions - 1) ? 'Finalizar Evaluaci√≥n üèÅ' : 'Siguiente ‚û°Ô∏è';
            nextQuestionBtn.style.display = 'block';
            
            updateProgress();
        }

        function nextQuestion() {
            const question = currentQuestionSet[currentQuestionIndex];
            const answer = userData.answers[question.id];
            
            let isValid = true;
            let errorMessage = '';
            
            if (question.type === 'binary' || question.type === 'options') {
                isValid = answer !== undefined && answer !== '';
                errorMessage = 'Por favor, selecciona una respuesta.';
            } 
            else if (question.type === 'number') {
                const numValue = parseFloat(answer);
                isValid = !isNaN(numValue) && numValue >= 0;
                errorMessage = 'Por favor, ingresa un n√∫mero v√°lido mayor o igual a 0.';
            } 
            else if (question.type === 'dimensions') {
                const dims = answer || {};
                const largo = parseFloat(dims.largo);
                const ancho = parseFloat(dims.ancho);
                
                isValid = !isNaN(largo) && largo > 0 && !isNaN(ancho) && ancho > 0;
                errorMessage = 'Por favor, ingresa valores v√°lidos para largo y ancho (mayores a 0).';
            }
            
            if (!isValid) {
                alert(errorMessage);
                return;
            }
            
            if (currentQuestionIndex < totalQuestions - 1) {
                showQuestion(currentQuestionIndex + 1);
            } else {
                evaluateAnswers();
            }
        }

        function prevQuestion() {
            if (currentQuestionIndex > 0) {
                showQuestion(currentQuestionIndex - 1);
            }
        }

        // --- L√ìGICA DE EVALUACI√ìN (PASO 3) ---

        function evaluateAnswers() {
            userData.failures = [];
            userData.recommendations = [];
            let allCriticalPassed = true;
            
            let legal_limit = 0;
            let calculated_capacity = 0; 
            let final_capacity = 0;
            let area = 0;
            let balonesCount = 0;
            let winning_clearance = 0;

            currentQuestionSet.forEach(question => {
                const answer = userData.answers[question.id];
                
                if (answer === 'N/A (Saltada)') return; 
                
                if (question.critical && question.condition && !question.condition(answer)) {
                    allCriticalPassed = false;
                    userData.failures.push(question.failureMessage);
                }
                
                if (!question.critical && question.recommendationMessage && question.condition && !question.condition(answer)) {
                     userData.recommendations.push(question.recommendationMessage);
                }
            });

            let public_limit = Infinity;
            if (userData.answers.public_nearby === 'S√≠, hay uno cerca') {
                const distance = parseFloat(userData.answers.public_distance || 0);
                public_limit = getLimitFromDistance(distance, publicClearanceTiers);
                
                if (public_limit === 0 && allCriticalPassed) {
                     allCriticalPassed = false;
                     userData.failures.push(`La distancia de ${distance}m a un lugar de afluencia p√∫blica es insuficiente. Se requiere un m√≠nimo de ${publicClearanceTiers[0].distance}m para la capacidad m√°s baja.`);
                }
            }

            if(allCriticalPassed) {
                userData.result = 'Aprobado';
                const answers = userData.answers;
                let capacityLimits = {}; 

                switch (selectedOption) {
                    case '1': // Rack
                        legal_limit = 120;
                        calculated_capacity = 120;
                        final_capacity = 120;
                        balonesCount = 12; 
                        area = 1; 
                        capacityLimits = {
                            base: 120,
                            ventilacion: 'No aplica',
                            pisos_superiores: 'No aplica',
                            publico: 'No aplica',
                            por_espacio: 120,
                            despeje_requerido: 'No aplica'
                        };
                        break;
                    
                    case '2': // Con Techo
                        const dims = userData.answers.storage_dimensions || {};
                        const totalLargo = parseFloat(dims.largo || 0);
                        const totalAncho = parseFloat(dims.ancho || 0);
                        
                        const capacityResult = calculateMaxCapacity(totalLargo, totalAncho);
                        calculated_capacity = capacityResult.capacity; 
                        winning_clearance = capacityResult.clearance;
                        
                        balonesCount = Math.floor(calculated_capacity / 10);
                        // El √°rea √∫til no se puede calcular tan f√°cil por la l√≥gica de pasillos,
                        // pero para el reporte, usaremos el √°rea basada en el despeje ganador
                        const usableLargo = totalLargo - (winning_clearance * 2);
                        const usableAncho = totalAncho - (winning_clearance * 2);
                        area = (usableLargo > 0 && usableAncho > 0) ? (usableLargo * usableAncho) : 0;
                        
                        const base_legal_limit = 5000; 
                        
                        const ventilacionMetros = parseFloat(userData.answers.ventilation_size || 0);
                        let ventilacion_limit = 0;
                        if (ventilacionMetros >= 30) {
                            ventilacion_limit = 5000;
                        } else if (ventilacionMetros >= 24) {
                            ventilacion_limit = 4000;
                        } else if (ventilacionMetros >= 18) {
                            ventilacion_limit = 3000;
                        } else if (ventilacionMetros >= 12) {
                            ventilacion_limit = 2000;
                        } else if (ventilacionMetros >= 6) { 
                            ventilacion_limit = 1000;
                        }
                        
                        const hayPisosArriba = userData.answers.pisos_superiores === 'S√≠, hay pisos arriba';
                        const pisos_limit = hayPisosArriba ? PISOS_SUPERIORES_LIMIT : Infinity;

                        legal_limit = Math.min(base_legal_limit, ventilacion_limit, pisos_limit, public_limit);
                        final_capacity = Math.min(legal_limit, calculated_capacity);
                        
                        if (final_capacity < calculated_capacity) {
                            balonesCount = Math.floor(final_capacity / 10);
                        }

                        capacityLimits = {
                            base: base_legal_limit,
                            ventilacion: ventilacion_limit,
                            pisos_superiores: hayPisosArriba ? PISOS_SUPERIORES_LIMIT : 'No aplica',
                            publico: (public_limit === Infinity) ? 'No aplica' : public_limit,
                            por_espacio: calculated_capacity,
                            despeje_requerido: winning_clearance
                        };
                        break;

                    case '3': // Sin Techo
                        const dims_3 = userData.answers.storage_dimensions || {};
                        const totalLargo_3 = parseFloat(dims_3.largo || 0);
                        const totalAncho_3 = parseFloat(dims_3.ancho || 0);
                        
                        const capacityResult_3 = calculateMaxCapacity(totalLargo_3, totalAncho_3);
                        calculated_capacity = capacityResult_3.capacity;
                        winning_clearance = capacityResult_3.clearance;

                        balonesCount = Math.floor(calculated_capacity / 10);
                        const usableLargo_3 = totalLargo_3 - (winning_clearance * 2);
                        const usableAncho_3 = totalAncho_3 - (winning_clearance * 2);
                        area = (usableLargo_3 > 0 && usableAncho_3 > 0) ? (usableLargo_3 * usableAncho_3) : 0;
                        
                        const base_legal_limit_3 = 50000;
                        legal_limit = Math.min(base_legal_limit_3, public_limit);
                        final_capacity = Math.min(legal_limit, calculated_capacity);

                        if (final_capacity < calculated_capacity) {
                            balonesCount = Math.floor(final_capacity / 10);
                        }

                        capacityLimits = {
                            base: base_legal_limit_3,
                            ventilacion: 'No aplica',
                            pisos_superiores: 'No aplica',
                            publico: (public_limit === Infinity) ? 'No aplica' : public_limit,
                            por_espacio: calculated_capacity,
                            despeje_requerido: winning_clearance
                        };
                        break;
                }
                
                userData.capacity = {
                    legal_limit: legal_limit,
                    area: area,
                    calculated_capacity: calculated_capacity,
                    final_capacity: final_capacity,
                    balones_count: balonesCount,
                    limits: capacityLimits
                };

            } else {
                userData.result = 'No Aprobado';
                userData.capacity = null;
            }

            showResults();
            goToStep(3);
        }

        function showResults() {
            resultContainer.innerHTML = '';
            let recommendationsHTML = '';
            
            if(userData.recommendations.length > 0) {
                userData.recommendations.forEach(rec => {
                    recommendationsHTML += `<div class="recommendation-item">üí° ${rec}</div>`;
                });
            }

            if (userData.result === 'Aprobado') {
                const cap = userData.capacity;
                let capacityHTML = '';

                if (selectedOption === '1') {
                     capacityHTML = `
                        <p>Tu modalidad es RACK/JAULA. El l√≠mite es fijo.</p>
                        <p class="final-capacity">Capacidad M√°xima: ${cap.final_capacity.toLocaleString()} kg</p>
                        <p><em>(Equivalente a ${cap.balones_count} balones de 10kg)</em></p>
                     `;
                } else {
                     const dims = userData.answers.storage_dimensions;
                     
                     let ventilacionHTML = '';
                     let pisosHTML = '';
                     let publicoHTML = '';
                     
                     if(selectedOption === '2') {
                        ventilacionHTML = `<li>L√≠mite por Ventilaci√≥n (${userData.answers.ventilation_size} m¬≤): <strong>${cap.limits.ventilacion.toLocaleString()} kg</strong></li>`;
                        let pisosLimitText = (typeof cap.limits.pisos_superiores === 'number') ? cap.limits.pisos_superiores.toLocaleString() : cap.limits.pisos_superiores;
                        pisosHTML = `<li>L√≠mite por Pisos Superiores: <strong>${pisosLimitText} kg</strong></li>`;
                     }

                     let publicoLimitText = (typeof cap.limits.publico === 'number') ? cap.limits.publico.toLocaleString() : cap.limits.publico;
                     if (publicoLimitText !== 'No aplica') {
                         publicoHTML = `<li>L√≠mite por Afluencia de P√∫blico: <strong>${publicoLimitText} kg</strong></li>`;
                     }
                     
                     capacityHTML = `
                        <p>Tu espacio TOTAL mide: <strong>${parseFloat(dims.largo).toFixed(1)}m x ${parseFloat(dims.ancho).toFixed(1)}m</strong></p>
                        <p>Considerando un despeje √≥ptimo de <strong>${cap.limits.despeje_requerido}m</strong> (y pasillos si son necesarios), tu capacidad M√ÅXIMA por ESPACIO √öTIL ("El Ganador") es: <strong>${Math.floor(cap.limits.por_espacio).toLocaleString()} kg</strong></p>
                        
                        <hr style="margin: 10px 0;">
                        
                        <p style="text-align:center;"><strong>L√≠mites Reglamentarios (Se aplica el m√°s bajo):</strong></p>
                        <ul>
                            <li>L√≠mite por tipo de Local (${userData.optionText}): <strong>${cap.limits.base.toLocaleString()} kg</strong></li>
                            ${ventilacionHTML}
                            ${pisosHTML}
                            ${publicoHTML}
                        </ul>
                        
                        <p style="text-align:center;">Tu L√≠mite Legal (el menor de los de arriba) es: <strong>${cap.legal_limit.toLocaleString()} kg</strong></p>
                        
                        <hr style="margin: 10px 0;">
                        
                        <p class="final-capacity">Capacidad M√°xima Aprobada: ${Math.floor(cap.final_capacity).toLocaleString()} kg</p>
                        <small style="text-align:center; display:block;">(Equivalente a ${cap.balones_count} balones de 10kg)</small>
                        <small style="text-align:center; display:block;">(Se aprueba el valor m√°s bajo entre tu L√≠mite Legal y tu Capacidad por Espacio)</small>
                    `;
                }

                resultContainer.innerHTML = `
                    <div class="result success">
                        <div class="result-icon">üéâ</div>
                        <h3>¬°Felicidades! Local APROBADO</h3>
                        <p>Has pasado la pre-evaluaci√≥n de seguridad. Tu espacio cumple con los requisitos cr√≠ticos.</p>
                        
                        <div class="capacity-box">
                            ${capacityHTML}
                        </div>
                        
                        <p style="margin-top: 15px; font-weight: bold;">Ac√©rcate a la oficina de Osinergmin con tu DNI. Tus respuestas est√°n guardadas para generar tu Declaraci√≥n Jurada.</p>
                    </div>
                     ${recommendationsHTML}
                `;
            } else {
                let failuresHTML = '<div class="failures-list"><h4>Debes corregir los siguientes puntos cr√≠ticos:</h4>';
                userData.failures.forEach(fail => {
                    failuresHTML += `<div class="failure-item">‚ùå ${fail}</div>`;
                });
                failuresHTML += '</div>';

                resultContainer.innerHTML = `
                    <div class="result danger">
                        <div class="result-icon">üö´</div>
                        <h3>Local NO APROBADO</h3>
                        <p>Tu espacio no cumple con uno o m√°s requisitos cr√≠ticos de seguridad.</p>
                        ${failuresHTML}
                        <p style="margin-top:20px;">Por favor, realiza las mejoras y vuelve a intentarlo. ¬°Estamos para ayudarte!</p>
                    </div>
                    ${recommendationsHTML}
                `;
            }

            if (userData.dni) {
                localStorage.setItem(`evaluacion_${userData.dni}`, JSON.stringify(userData));
            }
            generateDeclaration();
            declaration.classList.remove('hidden');
        }

        function generateDeclaration() {
            declDni.textContent = userData.dni || 'No registrado';
            let contenido = `
                <p><strong>Tipo de Almac√©n:</strong> ${userData.optionText}</p>
                <p><strong>Resultado:</strong> ${userData.result}</p>
                
                ${userData.result === 'Aprobado' ? `<p><strong>Capacidad Aprobada:</strong> ${Math.floor(userData.capacity.final_capacity).toLocaleString()} kg (${userData.capacity.balones_count} balones)</p>` : ''}
                
                <strong>Respuestas Marcadas:</strong>
                <ul>
            `;
            
            currentQuestionSet.forEach(q => {
                const answer = userData.answers[q.id];
                let answerText = answer;

                if(typeof answer === 'object' && answer !== null) {
                    answerText = `Largo: ${answer.largo}m, Ancho: ${answer.ancho}m`;
                }
                
                if(answer !== 'N/A (Saltada)') {
                     contenido += `<li><strong>${q.text}:</strong> ${answerText}</li>`;
                }
            });
            
            contenido += `</ul>`;
            
            if (userData.failures.length > 0) {
                 contenido += `<p><strong>Puntos Cr√≠ticos Fallidos:</strong></p><ul>`;
                 userData.failures.forEach(f => { contenido += `<li>${f}</li>`; });
                 contenido += `</ul>`;
            }
            if (userData.recommendations.length > 0) {
                 contenido += `<p><strong>Recomendaciones (No Cr√≠ticas):</strong></p><ul>`;
                 userData.recommendations.forEach(r => { contenido += `<li>${r}</li>`; });
                 contenido += `</ul>`;
            }

            declarationContent.innerHTML = contenido;
        }

        function printDeclaration() {
            window.print();
        }

        function restartEvaluation() {
            currentStep = 1;
            currentQuestionIndex = 0;
            selectedOption = null;
            
            // --- Resetear los questionSets ---
            // Esto es un poco "feo" pero asegura que se reinicien si se modificaron
            const basePublicQuestions = [
                { id: 'public_nearby', text: '¬øExisten lugares de afluencia de p√∫blico cercanos? ...', type: 'binary', options: ['S√≠, hay uno cerca', 'No hay ninguno'], critical: false },
                { id: 'public_distance', text: '¬øA cu√°ntos metros est√° el lugar de afluencia de p√∫blico m√°s cercano?', type: 'number', helpText: 'Mida la distancia...', critical: false, dependsOn: { id: 'public_nearby', value: 'S√≠, hay uno cerca' }, condition: (answer) => true, failureMessage: '' }
            ];

            // Filtrar las preguntas viejas
            questionSets[2] = questionSets[2].filter(q => q.id !== 'public_nearby' && q.id !== 'public_distance');
            questionSets[3] = questionSets[3].filter(q => q.id !== 'public_nearby' && q.id !== 'public_distance');
            
            // Re-a√±adir las preguntas en la posici√≥n correcta (regener√°ndolas por si acaso)
            questionSets[2].splice(5, 0, ...basePublicQuestions.map(q => ({...q}))); // Copia profunda simple
            questionSets[3].splice(3, 0, ...basePublicQuestions.map(q => ({...q}))); 
            // --- Fin Reseteo ---

            currentQuestionSet = [];
            userData.option = '';
            userData.optionText = '';
            userData.answers = {};
            userData.result = '';
            userData.failures = [];
            userData.recommendations = [];
            
            optionCards.forEach(card => card.classList.remove('selected'));
            declaration.classList.add('hidden');
            questionDisplay.innerHTML = '';
            
            dniInput.disabled = false;
            saveDniBtn.disabled = false;
            dniMessage.textContent = '';
            
            goToStep(1);
            updateProgress();
        }
    </script>
</body>
</html>
